第一章 绪论
（a）计算
	算法
	※ 计算 = 信息处理
	借助某种工具，遵照一定规则，以明确而机械的形式进行
	※ 计算模型 = 计算机 = 信息处理工具
	※ 算法：特定计算模型下，旨在解决特定问题的指令序列
		输入 ： 带处理的信息（问题）
		输出 ： 经处理的信息（答案）
		正确性 ： 的确可以解决指定的问题
		确定性 : 任一算法都可以描述为一个由基本操作组成的序列
		可行性 ： 每一基本操作都可实现，且在常数时间内完成
		有穷性 ： 对于任何输入，经有穷次基本操作，都可以得到输出
		...
		
	※ 有穷性
	Hailstone序列	
★	代码 求Hailstone序列长度
	int hailstone(n)
	{
		int length = 1;
		while(n>1)
		{
			(n%2)? n=3*n+1 : n/=2;  //n为奇数则变为3*n+1，n为偶数则折半
			length++;
		}
		return length;
	}
	
	※ 程序未必是算法，如程序出现死循环或栈溢出，算法具有有穷性。
	※ 好算法： 正确、健壮、可读、效率
	
	
（b）计算模型
	※ 计算：数据结构Data Structure + 算法Algorithm （DSA） 
	※ 算法分析： 正确性和成本（运行时间 + 所需存储空间）
	※ 通常：规模接近，计算成本也接近；规模扩大，计算成本亦上升
	※ 最坏情况：稳妥起见，在规模同为n的所有实例中，只关注最坏（成本最高）者，
	即取 T(n) = max{ T(P) | |P| = n}
	由于程序员、语言、编译器、操作系统等不同，同一算法性能也不尽相同，故无法客观评判算法效率。
	为此，需要抽象出理想的平台或模型，直接准确地描述、测量、评价算法。――――TM模型和RAM模型
	
	※ 图灵机模型 Turing Machine(TM)：具有以下要件
		Tape（带） ：依次均匀地划分为单元格cell，各注有某一字符（如0,1），默认为‘#’
		Alphabet（字符表）：cell中所标字符来自于字符表，字符的种类有限
		Head（读写头）：总是对准tape上的某一个cell，并可读取和改写其中的字符，
		                每经过一个节拍，可转向左侧或右侧的邻格
		State（状态） ：TM（读写头）总是处于有限种状态中的某一种，
						每经过一个节拍，可（按照规则）转向另一种状态
		Transition Function（转换函数，即规则）：(q, c; d, L/R, p) 若当前状态为q且当前字符为c，
						则将当前字符改写为d；转向左侧/右侧的邻格；转入p状态。
						一旦转入特定的状态‘h’，则停机。
	
	※ 基于TM模型实现的具体算法实例：Increase
★	功能：将二进制非负整数加一
	( <, 1, 0, L, < ) //左行，1->0
	( <, 0, 1, R, > ) //掉头， 0->1
	( <, #, 1, R, > )
	( >, 0, 0, R, > ) //右行
	( >, #, #, L, h ) //复位
	之所以要进行最后两步，将读写头复位，是为了规范性，为日后做接口做准备
	
	※ RAM模型（Random Access Machine，随机存取机器模型）
		寄存器顺序编号，总数没有限制
			R[0], R[1], R[2], ...
		每一基本操作仅需常数时间
			R[i] <- c
			R[i] <- R[j]     直接取址
			R[i] <- R[R[j]]  间接取址
			R[i] <- R[j] + R[k]（支持加减法，但不允许对常数进行）		
			IF R[i]>0 GOTO 1 条件判断语句和转向语句，其中1为顺序语句的编号
			STOP
		与TM模型一样，RAM模型也是一般计算工具的简化与抽象，
		使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。
		在这些模型中，
			算法的运行时间 ∝ 算法需要执行的基本操作次数
			T(n) = 算法为求解规模为n的问题，所需执行的基本操作次数
		
	※ 基于RAM模型实现的具体算法实例：Floor
	功能：向下取整的除法  
	即，计算不超过c/d的最大整数，其中c>=0, d>0
★	算法：反复地从R[0] = 1+c 中减去R[1] = d，统计在下溢（R[0]<0）之前，所做减法的次数x
	0	R[3] <- 1				//increment 预处理，因为加减都不允许对常数进行
	1	R[0] <- R[0] + R[3]		//c+1
	2	R[0] <- R[0] - R[1]		//c-=d
	3	R[2] <- R[2] + R[3]		//x++  R[2]为计数器，初值为0
	4	IF R[0]>0 GOTO 2		//if c>0 goto 2  转向第2个语句
	5	R[0] <- R[2] - R[3]		//else x-- and
	6	STOP					//return R[0]=x
	
	执行过程可以记录为一张表，表的行数即是所执行基本指令的总条数，能够客观度量算法的执行时间。
	图灵机、RAM等模型为度量算法性能提供了准确的尺度。
	
	
（c）大O记号
	随着问题规模的增长，计算成本如何增长？这里更关心足够大的问题，注重考查成本的增长趋势。
	※ 渐进分析：大O记号（big-O notation）
		T(n) = O(f(n))  
	条件：存在 c > 0，当 n>>2后，有T(n) < c*f(n)，即只要定好常系数c，O经过放大能够完成构成上界的功能。
	常系数可忽略：O(f(n)) = O(c*f(n))
	低次项可忽略
	※ O(1) 常数复杂度
		常数的四则运算、高次方等，此类算法效率最高、
		不含转向（循环、调用、递归等），必顺序执行，即是O(1)
	
	※ O(logn) 对数复杂度
		常底数无所谓，常数次幂无所谓
		此类算法非常高效，复杂度无限接近于常数O(1)
		∵ 对于任意 c>0, logn = O(n^c)，即对于任意正数c，logn可以在O记号的意义下，被n的c次方所掩盖

	※ O(n^c) 多项式复杂度 ――――仍是可解问题
		估算时去掉低次幂和常数
		线性复杂度：所有O(n)类函数
		从O(n)到O(n^2)：编程习题主要覆盖的范围

	※ O(2^n) 指数复杂度 ――――难解问题
		此类算法计算成本增长极快，通常被认为不可忍受
		从O(n^c)到O(2^n)，是从有效算法到无效算法的分水岭
		很多问题的O(2^n)算法显而易见，然而设计出O(n^c)算法却极其不易。


（d）算法分析
	※ 两个主要任务 = 正确性（不变形 * 单调性）+ 复杂度
	※ 复杂度分析的主要方法：
		迭代：级数求和
		递归：递归跟踪 + 递推方程
		猜测 + 验证
	
	※ 级数
	算数级数：与末项平方同阶 T(n) = 1+2+...+n = O(n^2)
	幂方级数：比幂次高出一阶 T(n) = 1^3+2^3+...+n^3 = O(n^4)
	几何级数（a>1）：与末项同阶 T(n) = a^0+a^1+...+a^n = O(a^n)
	收敛级数：O(1)
	可能未必收敛，然而长度有限  
★	h(n) = 1 + 1/2 + 1/3 + ... + 1/n = Θ(logn)     //调和级数
★	log1 + log2 + ... + logn = log(n!) = Θ(nlogn)  //对数级数
	（需要记住！！！）   其中，Θ为确界，O为上界，Ω为下界
	
	※ 循环 vs 级数 （借助级数知识，分析代码中循环的复杂度）
	例：for (int i=0; i<n; i++)
			for (int j=0; j<n; j++)
				O(1)Operation(i,j)
		算数级数： n+n+n+...+n = n*n = O(n^2)
		等效为以i,j为坐标轴的矩形面积
		
	例：for (int i=0; i<n; i++)
			for (int j=0; j<i; j++)
				O(1)Operation(i,j)
		算数级数： 0+1+2+...+(n-1) = n*(n-1)/2 = O(n^2)
		等效为以i,j为坐标轴的三角形面积

	例：for (int i=0; i<n; i++)
			for (int j=0; j<i; j+=2013)
				O(1)Operation(i,j)
		算数级数： O(n^2)
		等效为三角形面积，将j轴压缩2013倍

	例：for (int i=1; i<n; i<<=1)  //i左移一位，相当于i*=2
			for (int j=0; j<i; j++)
				O(1)Operation(i,j)
		几何级数： O(n)

	※ 算法分析：以冒泡排序为例
	不变性：经k轮扫描交换后，最大的k个元素必然就位
	单调性：经k轮扫描交换后，问题规模缩减至n-k
	正确性：经至多n趟扫描后，算法必然终止，且能给出正确解答
	
	
（e）迭代与递归
	※ 递归在效率上并不占优
	※ 空间复杂度指除去输入所占的空间，其余另加的完成运算所需的空间总量
	
	※ 迭代与递归的思想都是减而治之（Decrease-and-conquer）
		为求解一个大规模的问题，可以
			将其划分为两个子问题：其一平凡，另一规模缩减  //单调性
			分别求解子问题
			由子问题的解，得到原问题的解                    
	
★	例：计算任意n个整数之和
		迭代：
		int SumI(int A[], int n)
		{
			int sum = 0;  //O(1)
			for (int i=0; i<n; i++)  //O(n)
				sum += A[i];  //O(1)
			return sum;  //O(1)
		}
		时间复杂度为 O(n)，空间复杂度为 O(2) （int sum 和int i）
	
		递归：
		sum(int A[], int n)
		{
			return (n<1)? 0 : sum(A, n-1)+A[n-1];
		}
		时间复杂度为 O(n)
		
		※ 求递归时间复杂度方法：
		递归跟踪分析（适用于简单情况）：
			检查每个递归实例，累计所需时间，其总和即算法执行时间
			本例中 T(n) = O(1)*(n+1) = O(n)		
		递推方程（适用于复杂情况）：
			为求解sum(A,n)，需递归求解规模为n-1的问题sum(A,n-1)  //T(n-1)
			再累加上A[n-1]										 //O(1)
			递归基：sum(A,0)									 //O(1)
			递推方程  T(n) = T(n-1) + O(1)
			          T(0) = O(1)
			求解： T(n) - n = T(n-1) + O(1) - n = T(n-1) - (n-1)
							= T(n-2) - (n-2) = ... = T(2) - (2)
							= T(1) - (1) = T(0)
				   T(n) = O(1) + n = O(n)
				   
★	例：数组倒置 任给数组区间A[0,n)，将其前后颠倒       							 ????★★★★????待实验
		统一接口：void reverse(int* A, int lo, int hi);
		递归版：
			if(lo < hi) //问题规模的奇偶性不变，需要两个递归基
			{ swap(A[lo],A[hi]); reverse(A, lo+1, hi-1); }
		迭代原始版：
		next:
			if(lo < hi)
				{ swap(A[lo],A[hi]); lo++; hi--; goto next; }
		迭代精简版：
		while(lo < hi) swap(A[lo++],A[hi--]);
	
	※ 分而治之（Divide-and-conquer）
		为求解一个大规模的问题，可以
			将其划分为若干（通常两个）子问题，规模大体相当
			分别求解子问题
			由子问题的解，得到原问题的解
			
★	例：数组求和	
	sum(0,7) = sum(0,3) + sum(4,7)
			 = sum(0,1) + sum(2,3) + sum(4,5) + sum(6,7)
			 = sum(0,0) + sum(1,1) + sum(2,2) + sum(3,3) + sum(4,4) + sum(5,5) + sum(6,6) + sum(7,7)
	时间复杂度 O(n)，因为 T(n) = 各层递归实例所需时间之和，满足几何级数，时间复杂度与末项同阶
	

（f）动态规划
	 可以理解为通过递归找出算法本质，得出初步解之后，再将其等效转化为迭代形式。
	 ※ Fibonachi数：{0,1,1,2,3,5,8,13，...}后一个数是前两个数的和，递归实现效率极低
★	    应用：上楼梯问题，每次只能迈一级或两级，问到达第六级总共有几种解法？
		      答：8种，即第六个Fibonachi数
	 ※ 最长公共子序列（的长度） LCS




	
	 
第二章 向量
（a） 无序向量
	  插入：O(n-r)       //插入元素的秩为r
	  区间删除：O(n-hi)  //删除区间的秩为[lo,hi)
	  单元素删除：O(n-r) //删除元素的秩为r
	  查找：最好O(1)，最差O(n)  //逆向查找，是输入敏感的算法
	  唯一化（去重）：O(n^2) ，简明实现最优的O(nlogn)――V.sort().uniquify()	  
	  
（b） 有序向量
	  二分查找：O(1.50*logn)  向左侧需要一次比较，向右侧需要两次比较  
	  （每次对n的数值折半）
	  Fibonachi查找：O(1.44*logn) 是最优的
	  二者区别在于middle point的选取，前者取中点0.5，后者取黄金分割点0.618
	  插值查找：O(loglogn)
	  （平均情况：每经过一次比较，n缩至√n）
	  （就像查字典时，按比例确定middle point，每次对n的数位宽度折半）
	  ※ 有序向量查找 总结：
	    首先通过插值查找，将查找范围缩小到一定的范围
		然后再进行二分查找

		
（c） 冒泡排序 bubbleSort
	  最坏时间复杂度  O(n^2)
	  最优时间复杂度  O(n)
	  平均时间复杂度  O(n^2)
	  空间复杂度	  总共 O(n)，需要辅助空间 O(1)
	  方法：检查每一对相邻元素是否都是顺序对，若否，则交换位置
	  改进：每一趟扫描交换，都记录下是否存在逆序元素（若存在，当且仅当做过交换）,
	  这样当前面的序列均有序时，可提前结束算法；
			记录每趟扫描最后一个逆序对的位置（最右侧），从而缩短下一次扫描的区间范围
	  冒泡排序是稳定的（stability），即出现相等元素时，排序之后其出现的顺序与排序前相同。
★	  代码：
	  #include <iostream>
	  using namespace std;
	  
	  template <typename T> //为了int float等类型都能用
	  void bubble_sort(T A[],int len)
	  {
			for(int i=0; i<len-1; i++)
				for(int j=0; j<len-1-i; j++)
					if(A[j]>A[j+1])
						swap(A[j],A[j+1])
	  }
	  int main()
	  {
			int arr[] = {2,5,3,23,4,7,6};
			int len = (int)sizeof(arr)/sizeof(*arr);
			bubble_sort(arr[],len);
			return 0;
	  }
	  
	  	  
	
（d） 归并排序 mergeSort  O(nlogn)――无论最好最坏，空间复杂度为O(n)
	  方法：序列一分为二；子序列递归排序；合并有序子序列。
	  T(n) = 2*T(n/2) + O(n)，其中O(n)为分、合所用时间
	  合并两个有序子序列方法：
	  5 → 8 → 13 → 21
	  2 → 4 → 10 → 29
	  
	  5 → 8 → 13 → 21
	  4 → 10 → 29			2
	  
	  5 → 8 → 13 → 21
	  10 → 29				2 → 4
	  
	  8 → 13 → 21
	  10 → 29				2 → 4 → 5
	  
	  13 → 21
	  10 → 29				2 → 4 → 5 → 8
	  
	  13 → 21
	  29				    2 → 4 → 5 → 8 → 10
	  
	  21
	  29		    		2 → 4 → 5 → 8 → 10 → 13
	  
	  
	  29				    2 → 4 → 5 → 8 → 10 → 13 → 21
	  

	       				    2 → 4 → 5 → 8 → 10 → 13 → 21 → 29
★    代码：
	  template <typename T>
	  void merge(T arr[], T reg[], int start, int end)
	  {
			if(start >= end) return;
			int len = end - start;
			int mid = start + (len >> 1)
			int start1 = start, end1 = mid;
			int start2 = mid+1, end2 = end;
			merge(arr, reg, start1, end1);
			merge(arr, reg, start2, end2);
			//开始合并
			int k = start;
			while(start1<=end1 && start2<=end2)
				reg[k++] = arr[start1]<arr[start2] ? arr[start1]):arr[start2];
			while(start1<=end1)
				reg[k++]=arr[start1];
			while(start2<=end2)
				reg[k++]=arr[start2];
			for(int i=0; i<len; i++)
				arr[i] = reg[i];
	  }
	  template <typename T>
	  void merge_sort(T arr[], const int len)
	  {
			T reg[] = new T[len];
			merge(arr, reg, 0, len-1);
			delete[] reg;
	  }
	

	
第三章 链表	
（a） 无序链表
（b） 有序链表 
（c） 选择排序 selectionSort  Θ(n^2) 即无最好最坏情况
	  即每次都从前面无序的部分中选择最大的，放在最后
	  （理解：对筐中的苹果排序，每次都取出筐中最大的）
	  后面是有序的部分，前面无序，且无序部分的最大值<=有序部分最小值
	  冒泡排序本质上也是一种选择排序，只是效率太低，因为要进行多次交换。


（d） 插入排序 insertionSort  O(n^2)  最好O(n)，最坏O(n^2)
	  将无序部分的值依次插入前面有序部分的合适位置
	  （理解：打牌时摸到新的牌，对其进行排序）
	  前面是有序的部分，后面无序，无序部分数据的大小范围不受有序部分限制
	  链表接口STL提供函数search(p)，可以返回不大于p的最大值（最后一个）位置





第五章 树
	  高度：从叶子节点往上数； 深度：从根节点往下数
（1） 二叉树
      二叉树是多叉树的特例，但在有根且有序时，多叉树均可转化并表示为二叉树。
	  方法：将多叉树按长子-兄弟法表示，然后旋转45度
	  
（2） 遍历（“序”指的是根节点的访问次序）  迭代（优于递归）
	(a) 先序遍历：先访问根节点，然后递归地访问左子树和右子树 
	    分为两步：自顶而下访问左侧链，走到头后自底而上访问右子树。
		方法：从根结点开始沿着左孩子一直走到头，在此过程中，每到达一个结点便访问其元素值，
		同时检测该结点是否有右孩子，如果有则将指向右孩子的引用入栈;
		左侧链走到头后，弹出一个栈顶引用作为本次循环的根节点，并重复步骤①，直到栈为空。
		特点：根 -> 左 -> 右
			  第一个访问的必定是root结点
		代码：
		
		
	(b) 中序遍历：先访问左子树，然后访问根节点，最后访问右子树
	    从根出发沿左分支下行，入栈，直到最深的节点――最先被访问者；
		弹出栈顶元素，然后转向该节点元素的右子树
	    特点：左 -> 根 -> 右
		      根据中序遍历的结果，再结合前序遍历的root结点去划分root结点的左右子树。
		代码：
		
	  
	(c) 后序遍历：
	    特点：左 -> 右 -> 根
			  最后访问的必定是root结点
		代码：
		
			  
    (d) 层次遍历：
	    特点：从左到右，从上到下
			  第一个访问的必定是root结点
		代码：

（3） 已知两种遍历，求另一种
	(a) 已知前中序
		前序第一个字母为根节点；
		在中序中找到根节点，左侧的为左子树，右侧的为右子树；
		若左子树存在，则前序的左子树部分的第一个字母（整个遍历的第二个字母）必为左子树的根节点，
			前序右子树部分的第一个字母为右子树的根节点；
		以此递归下去...
		画出树
		
	(b) 已知中后序
		后序最后一个字母为根节点；
		在中序中找到根节点，左侧的为左子树，右侧的为右子树；
		若左子树存在，则后序的左子树部分的最后一个字母必为左子树的根节点，
			后序右子树部分的最后一个字母（整个遍历的倒数第二个字母）为右子树的根节点；
		以此递归下去...
		画出树

	(c) 已知前后序，无法唯一确定二叉树
		因为当一个根只有一颗子树时，通过前序遍历和后序遍历，无法确定该子树是这个根的左子树还是右子树。


第六章 图
（1） 广度优先搜索 BFS   O(n+e)
	  根据策略确定不同顶点接受访问的次序，并按照次序对各顶点逐个地访问
	  搜索过程的成果即选择原图的一系列边，并忽略另一些边不予进一步考虑
	  取舍原则：按照与顶点S的距离，将所有顶点划分为若干个等价类，同一等价类内部各顶点之间的边均忽略，
	  连接相邻等价类顶点的某些边（并非全部，避免造成环路）才会被采纳
	  最终构成一个极大无环图（即一棵树）
	  等同于树的层次遍历
	  若图存在多个连通域，只经过一次BFS搜索不能覆盖所有顶点，则加入循环，
	  找到状态仍为UNDISCOVERED的顶点，启动新一轮BFS
	  每个节点到顶点S之间的路径都是最短路径
	  
（2） 深度优先搜索 DFS
	  前序，中序和后序遍历都是深度优先遍历的特例。
	  



第七章 二叉搜索树
（1）二叉搜索树 BST
中序遍历是有序的二叉树，不能存在相同元素
查找：时间复杂度O(h)，h为树的深度
	  查找过程可以等效为向量的二分查找，
	  返回的引用值：成功时指向关键码为e（待查找的）且真实存在的节点；
					失败时指向最后一个试图转向的空节点NULL（看做哨兵）
	  实现代码中返回参数包含一个_hot（记忆热点），指向命中节点的父亲。
插入：时间复杂度O(h)，h为树的深度
	  将待插入的关键码封装为一个节点，其父亲节点即为查找操作返回的_hot，
	  将其对应的孩子引用指向待插入的新节点。
	  待插入的节点在之前都为空，因此插入后必为叶子节点。
★	  BinNodePosi(T) &x = search(e);
	  if(!x){  //查找失败时才实施插入操作
		x = new BinNode<T>(e, _hot);  //在x处创建新节点，以_hot为父亲
		_size++; updateHeightAbove(x);
	  }
删除：时间复杂度O(h)，h为树的深度
	  情况一：若待删除节点的至少一棵子树为空，则将存在的子树节点替换到待删除节点位置上即可；
	  情况二：若两棵子树均存在，则找到待删除节点的中序遍历下的直接后继（不小于该节点的最小节点，必无左孩子），
	  将其与待删除节点替换，则问题转化为第一种情况，令其唯一不空的孩子顶替它。

性能：n个节点的BST的平均高度：O(√n)  构成拓扑结构互异的BST个数：catalan(n)，卡特兰数
平衡：节点数目固定时，兄弟子树高度越接近（平衡），全树也将倾向于更低。
	  理想平衡：由n个节点组成的二叉树，高度不低于logn（向下取整）恰为logn（向下取整）时，称作理想平衡
	  适度平衡：高度渐进地不超过O(logn)，即可称作适度平衡。
	  适度平衡的BST，称作平衡二叉搜索树（BBST）
等价变换：通过旋转等操作，将BST转换为BBST，代价极小，不超过O(logn)
	  
（2） AVL树（Adelson-Velsky and Landis' tree）
	  一种BBST，未必是完全二叉树
	  平衡因子：左右子树高度之差，不超过1
	  适度平衡：高度渐进地不超过O(logn)；高度为h的AVL树，至少包含S(h)=fib(h+3)-1 个节点
				推导： S(h)=1+S(h-1)+S(h-2) => S(h)+1 =[S(h-1)+1]+[S(h-2)+1] => T(h)=T(h-1)+T(h-2)
查找：继承BST类，可直接沿用BST::search()等接口

插入：插入删除操作可能造成AVL树失衡，插入可能引起所有祖先失衡，而删除只会造成一个祖先失衡。
	  “单旋”：同时有多个失衡节点，最低者经单旋调整后复衡，子树高度复衡，全树复衡。
			  适用于 祖孙几代节点朝向一致
	  “双旋”：一次顺时针，一次逆时针
		      适用于 祖孙几代呈“之”字形式
删除：“单旋”：同时至多一个失衡节点g，首个可能就是x的父亲_hot；
		      g经单旋调整后复衡，但子树高度未必复原，更高祖先仍可能失衡；
			  因有失衡传播现象，可能需做O(logn)次调整。
	  “双旋”：“之”字型

“3+4”重构：实现结构调整（“单旋”和“双旋”的说法仅为帮助理解，实际操作时并不是通过旋转操作来调整结构的）
	       设g(x)为最低的失衡节点，祖孙三代节点 g~p~v，按中序遍历次序将其重命名为 a<b<c；
		   它们总共拥有互不相交的4棵（可能为空的）子树，按中序遍历次序将其重命名为 T0<T1<T2<T3
		   利用a b c 和 T0 T1 T2 T3可以设计好树的结构，并将其作为函数的形参。
		   调用函数时只需根据不同的情况，将需要调整的3个节点和4棵子树按正确的顺序重命名，传入函数即可。
		   如：connect34(v, p, g, v->lChild, v->rChild, p->rChild, g-<rChild)
 

第八章 高级搜索树
（1）B树（也叫B-树） O(logmN) m取256时，树高（IO次数）约降至1/7
	 BST与BBST查找效率与树的深度相关，降低树深度可以提高查找效率。
	 多叉树，数据库索引技术里大量使用着B树和B+树的数据结构。
	 充分利用磁盘块的原理，把节点大小限制和充分使用在磁盘快大小范围，使树层级变少，减少数据查找次数和复杂度。
	 （磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）
	 结构：树中的每个节点最多拥有m（m>=2）个子节点；
		   除根节点外，每个节点的关键字数量大于等于ceil(m/2)-1，小于等于m-1个，ceil为向上取整，称为(ceil(m/2),m)树，m路查找树，如(3,5)树；
		   所有节点关键字是按递增次序排列；
		   所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针（为null，查找失败时的返回值）。
		   包含n个关键码的m阶B树的最大高度：h = log(ceil(m/2))[(n+1)/2]  根高度为0
★	例：10阶B树，除根节点外，其余树根节点包含关键字最少4个，最多9个；根节点包含关键字最少1个，最多9个。	  
	    5阶B数，包含53个关键码，则最大高度：3        最小高度：2        上下浮动十分有限
		根关键字范围[1,4]，其余关键字范围[2,4]  
		最大高度：根1个关键字，其余2个关键字；        最小高度：所有节点4个关键字
		关键字个数    1         关键字总和   1			4			4
			          2*2					 5			5*4 	    24
					  2*2*3					 17			5*4*5	    124
					  2*2*3*3				 53
		
		
		   
	 插入：插入后若节点关键码数量越界，则拆分，将第ceil(m/2)个关键码（中间值）提升合并到其父节点
	 删除：删除后若节点关键码数量越界（过少），则合并，
	 
	 
（2）红黑树
	 一种BBST，任何一次动态操作引发的结构变化量不致超过O(1)








###########################
动态规划
转自：http://www.cnblogs.com/raichen/p/5772056.html
通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
动态规划常常适用于有重叠子问题和最优子结构性质的问题。

基本思想
若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 
通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 
一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 
这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。


	
	
	
	
	
	
	

	
	
	














附录 
1、 n++ 和 ++n
	单独使用时（如 return n++; 和 return ++n;）无区别；
	放在复合等式中时，n++要去掉++号，先将单独的n参与运算，最后令n+1；
	而++n要先将n+1，然后再进行其余运算。例如：
	int n = 1;
	a = (n++)+1;
	结果为 a = 2, n = 2
	int n = 1;
	a = (++n)+1;
	结果为 a = 3, n = 2
	
2、 for循环（）中的运行顺序
		除去初始的那次，先进行i++和j++，若+1后的i或j满足判断条件（如i<n），才进行Operation，
		如进行完j=i-1那步，j++后不满足j<i，则跳出当前循环（此时j=i），继续外面的循环体对i++
	例：for(i=0; i<n; i++)
			for(j=0; j<i; j++)
				Operation(i,j);
	第一步：i=0,j=0,不满足j<i，不执行Operation
	第二步：i=1,若i<n，则进行内循环j=0,满足j<i，执行Operation；若不满足i<n，则跳出循环
	第三步：i=1,j=1，不满足j<i，不执行Operation，跳到外循环
	第四步：i=2，若i<n则继续，不满足则跳出循环
	...
	
3、 指针
	指针是存地址的变量，程序中一般通过指针来访问其指向的内存地址中的内容（数据）。
	指针就是地址，指针值就是地址值。指针变量就是存放指针的变量。
	一个指针是有类型的，也就是一个地址是有类型的。
	指针是有运算的，int *p=&a;那么p++实际上加了sizeof(int)这么多个字节。也就是说加了一个int元素应该占用的字节，
	这样在数组中我们可以通过这种方式从上一个元素很方便的让指针变量指向下一个元素。
	
4、 * 和 &
	*	
	指针的声明：int *p （C语言中）或 int* p（C++中）; 读法：p是指向一个整数类型的指针。
	复合指针： int **p; 或 int** p; 读法 p是一个指向一个指向整数类型的指针的指针。
	解引用： x=*p 把指针p指向的值赋值给x

	&
	逻辑与：if((a>1)&&(b<0))
	位运算与：x = a&b;
	逻辑与赋值：x&=y;与 x=x&y含义相同
	求地址运算符：p=&x;  读法：把x的地址赋给p（指针）
	C++中特有：引用，是一种新的使用变量的方式，即给实际变量起个别名，通过这个别名来引用实际的变量。
		引用变量本身没有自己的实际存储空间，操作引用变量，就是在操作实际变量。	
		计算机必须在声明r的同时就要对它初始化，并且，r一经声明，就不可以再和其它对象绑定在一起了。
★	例：
	int x = 2;
	int* p;     //定义指针变量p
	p = &x;     //将x的地址赋给p
	int y = *p; //将指针p指向的数据赋给y，y=2
	其中，p和&x的类型为int* ,*p和y的类型为int

5、 重载
	函数重载：
		例如 Swap(int a, int b);  Swap(float a, float b);
	运算符重载：
		C++中预定义的运算符的操作对象只能是基本数据类型。
		但实际上，对于许多用户自定义类型（例如类），也需要类似的运算操作。
		运算符重载是通过创建运算符函数实现的，
		运算符函数的函数名是由关键字operator和其后要重载的运算符符号构成的。
		运算符函数定义的一般格式如下：
			<返回类型说明符> operator <运算符符号>(<参数表>)
			{

				<函数体>

			}

6、 C++ 类成员函数
	类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。
	类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。
	C++普通成员函数本质上是一个包含指向具体对象this指针的普通函数，
	即C++类的普通成员函数都隐式包含一个指向当前对象的this指针。
	成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。
★	例：
	class Box
	{
		public:
        double length;      // 长度
        double breadth;     // 宽度
        double height;      // 高度
   
        double getVolume(void)
        {
           return length * breadth * height;
        }
	};
	也可以在类的外部使用范围解析运算符 :: 定义该函数，如下所示：
	double Box::getVolume(void)
	{
		return length * breadth * height;
	}
	
	注意，在 :: 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符（.）
	Box myBox;          // 创建一个对象
	myBox.getVolume();  // 调用该对象的成员函数
	
	静态成员变量：
	类体中的数据成员的声明前加上static关键字，具有如下性质：
	1）static型变量只被初始化一次，下次执行初始化语句会直接跳过。
	2）经过static修饰的成员变量属于这个类，不再仅仅属于具体的对象。
	
	静态成员函数：
	1）不可以调用类的非静态成员。
	2）静态成员函数不含this指针。 静态成员函数属于这个类，不再仅仅属于具体的对象。
	
	因此类的静态成员函数和类的普通成员函数的区别是：
		静态成员函数不包含指向具体对象的this指针；
		普通成员函数包含一个指向具体对象的this指针。
	
7、 ::
	:: 叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。
	:: 可以不跟类名，表示全局数据或全局函数（即非成员函数）。
	
8、 友元（友元函数、友元类和友元成员函数）
	友元(friend)机制允许一个类将对其非公有成员的访问权授予指定的函数或者类。
	友元的声明以friend开始，它只能出现在类定义的内部（类中的任何地方）
	
	友元函数：
	指某些虽然不是类成员函数却能够访问类的所有成员的函数。
★	例：
	class A  
	{  
		public:  
			friend void set_show(int x, A &a);      //该函数是友元函数的声明  
		private:  
			int data;  
	};  
  
	void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员  
	{  
		a.data = x;  
		cout << a.data << endl;  
	}  
	int main(void)  
	{  
		class A a;   
		set_show(1, a);    
		return 0;  
	}

	友元类：
	类B的所有成员函数都是类A的友元函数，都可以访问另一个类中的隐藏信息。
	注意：
	(1) 友元关系不能被继承。
	(2) 友元关系是单向的，不具有交换性。
	(3) 友元关系不具有传递性。
★	例：
	class A  
	{  
		public:  
			friend class C;                         //这是友元类的声明  
		private:  
			int data;  
	};  
  
	class C             //友元类定义，为了访问类A中的成员  
	{  
		public:  
			void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}  
	};  
  
	int main(void)  
	{  
		class A a;  
		class C c;    
		c.set_show(1, a);    
		return 0;  
	}

	友元成员函数：
	类B中的成员函数是类A的友元函数。
	先声明类A，然后定义类B，定义类A（将B的成员函数设为友元），最后定义友元成员函数
★	例：
	class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明  
	class B  
	{  
		public:  
			void set_show(int x, A &a);             //该函数是类A的友元函数  
	};  
  
	class A  
	{  
		public:  
			friend void B::set_show(int x, A &a);   //该函数是友元成员函数的声明  
		private:  
			int data;  
			void show() { cout << data << endl; }  
	};  
  
	void B::set_show(int x, A &a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员  
	{  
		a.data = x;  
		cout << a.data << endl;  
	}  
  
	int main(void)  
	{  
		class A a;  
		class B b;    
		b.set_show(1, a);   
		return 0;  
	}  
	
9、 面向对象的三大特征：
	封装：可以隐藏实现细节，使得代码模块化。目的 —— 代码重用
	多态：为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。目的 —— 接口重用
	继承：可以扩展已存在的代码模块（类）。目的 —— 代码重用

（1）封装：
	就是将数据或函数等集合在一个个的单元中（称为类），被封装的对象通常被称为抽象数据类型。 
	简单地说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。
	意义：保护或者防止代码（数据）被我们无意中破坏。
	1. 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==>数据封装。
	2. 方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==>方法封装。 
	3. 当对象含有完整的属性和与之对应的方法时称为封装。
	4. 从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。
	5. 对象的方法可以接收对象外面的消息。
	权限：
	private：  同一个类 
	protected：同一个类  同包  不同包，子类
	public：   同一个类  同包  不同包，子类  不同包，非子类
	默认：     同一个类  同包
	
	
（2）继承：	
	是指可以让某个类型的对象获得另一个类型的对象的属性的方法。
	它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
	继承主要实现重用代码，节省开发时间。
	继承的过程，就是从一般到特殊的过程。
	
	
（3）多态：
	“一个接口，多种方法”
	同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。
	利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消息的对象自行决定，如是，同一消息即可调用不同的方法。
	例如：同样是 run 方法，飞鸟调用时是飞，野兽调用时是奔跑。
	多态性的实现受到继承性的支持，利用类继承的层次关系，把具有通用功能的协议存放在类层次中尽可能高的地方，而将实现这一功能的不同方法置于较低层次，
	这样，在这些低层次上生成的对象就能给通用消息以不同的响应。
	在面向对象程序设计语言中可通过在派生类中重定义基类函数（定义为重载函数或虚函数）来实现多态性。
	
	多态的三个条件:
	a. 继承的存在(继承是多态的基础,没有继承就没有多态)
	b. 子类重写父类的方法(多态下调用子类重写的方法)
	c. 父类引用变量指向子类对象(子类到父类的类型转换)  A a = new B()  其中A为父类
	重载（overload）和重写（override）是实现多态的两种主要方式。
	
	静态多态（早绑定）
	以重载为基础
	如下例，互为重载的两个函数，程序在编译阶段根据参数个数确定调用哪个函数，叫静态多态。
★	例：
	class Rect       //矩形类
	{
	public:
		int calcArea(int width);
		int calcArea(int width,int height);
	};
	int main()
	{
		Rect.rect;
		rect.calcArea(10);
		rect.calcArea(10,20);
		return 0;
	}	
	
	动态多态（晚绑定）
	以封装和继承为基础
	比如计算面积，有一个计算面积的形状基类，圆形和矩形类派生自形状类，圆形与矩形的类各有自己的计算面积的方法。
	实现动态多态必须使用虚函数。
	
	
	
	
10、编译和运行
	编译：编译时就是简单的作一些翻译工作，编译器把源代码翻译成机器能识别的代码，
		  （比如Java只有JVM识别的字节码），vs中点build。
		  此时做的检查叫静态类型检查，就是没把真把代码放内存中运行起来,而只是把代码当作文本来扫描下
	运行：代码跑起来了.被装载到内存中去了，vs点start debugging
		  与静态类型检查不同，不是简单的扫描代码.而是在内存中做些操作和判断。
★	例：
	C++中：
	int arr[] = {1,2,3};
	int result = arr[4];
	cout<<result<<endl;
	编译时无错，debug时报错，但不是C++支持的特性，而是vs的一些工具所做的检查，
	如果点release则不会报错，而会返回一个不确定的值。
	C#中：
	int[] arr = { 1, 2, 3 };
	int result = arr[4];
	Console.WriteLine(result);
	编译时通过，运行时报错。C#C++不同，会检查数组是否越界
	
11、编译时类型和运行时类型
	对象调用编译时类型的属性和运行时类型的方法。
	编译时类型由声明该变量时使用的类型决定，	
	运行时类型由实际赋给该变量的对象决定。

12、C++中“箭头（->）”和“点号（.）”操作符的区别
	箭头（->）：左边必须为指针；
	点号（.）：左边必须为实体。
	A *p则使用：p->play(); 左边是结构指针。
	A p 则使用：p.paly(); 左边是结构变量。
	
	

13、C++虚函数
	基于向上类型转换，基类通过虚函数可以对多个子类相似的功能实现统一管理。
	class A
	{
		virtual void display(){cout<<"我是A"<<endl；}
	}
	class B:public A
	{
		void display(){cout<<"我是B"<<endl；}
	}
	class C:public A
	{
		void display(){cout<<"我是C"<<endl；}
	}
	void display(A s)//以A类型作为参数的顶层函数，不同于类中的成员函数
	{
		s.display();//调用对象s的成员函数
	}
	int main()
	{
		A x1;
		B x2;
		C x3;
		display(x1);//显示：我是A。
		display(x2);//参数x2向上转换为x1类型，显示：我是B。
		display(x3);//参数x3向上转换为x1类型，显示：我是C。
	}


	接口类：
	在抽象类当中仅含有纯虚函数而不含其他任何东西。
	（纯虚函数没有函数体，同时在定义的时候函数名后面要加“=0”。）
	特点：没有任何数据成员；仅有成员函数；成员函数都是纯虚函数
	class Shape
	{
		virtual double calcArea()=0//计算面积
		virtual double calcPerimeter()=0//计算周长
	};
	实际的工作中接口类更多的表达一种能力或协议
	
















	